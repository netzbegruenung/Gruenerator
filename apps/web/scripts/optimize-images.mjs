#!/usr/bin/env node
/**
 * Image Optimization Script
 *
 * Converts PNG/JPG preview images to WebP format with resizing.
 * Also generates tiny LQIP (Low Quality Image Placeholder) base64 strings.
 *
 * Usage: node apps/web/scripts/optimize-images.mjs
 */

import sharp from 'sharp';
import { readdir, stat, writeFile } from 'fs/promises';
import { join, extname, basename, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const PUBLIC_DIR = join(__dirname, '..', 'public', 'imagine');

const MAX_WIDTH = 600;
const WEBP_QUALITY = 80;
const LQIP_WIDTH = 20;

const IMAGE_DIRS = [
  join(PUBLIC_DIR, 'previews'),
  join(PUBLIC_DIR, 'variants'),
  join(PUBLIC_DIR, 'variants-pure'),
  PUBLIC_DIR,
];

const SUPPORTED_EXTENSIONS = ['.png', '.jpg', '.jpeg'];

async function getImageFiles(dir) {
  try {
    const entries = await readdir(dir);
    const files = [];
    for (const entry of entries) {
      const fullPath = join(dir, entry);
      const s = await stat(fullPath);
      if (s.isFile() && SUPPORTED_EXTENSIONS.includes(extname(entry).toLowerCase())) {
        files.push(fullPath);
      }
    }
    return files;
  } catch {
    return [];
  }
}

async function optimizeImage(filePath) {
  const ext = extname(filePath).toLowerCase();
  const name = basename(filePath, ext);
  const dir = dirname(filePath);
  const webpPath = join(dir, `${name}.webp`);

  const image = sharp(filePath);
  const metadata = await image.metadata();

  const needsResize = metadata.width > MAX_WIDTH;
  const resizeOpts = needsResize ? { width: MAX_WIDTH } : {};

  await sharp(filePath)
    .resize(resizeOpts)
    .webp({ quality: WEBP_QUALITY })
    .toFile(webpPath);

  const originalSize = (await stat(filePath)).size;
  const webpSize = (await stat(webpPath)).size;
  const reduction = ((1 - webpSize / originalSize) * 100).toFixed(1);

  return {
    original: filePath,
    webp: webpPath,
    originalSize,
    webpSize,
    reduction,
    width: needsResize ? MAX_WIDTH : metadata.width,
  };
}

async function generateLQIP(filePath) {
  const buffer = await sharp(filePath)
    .resize({ width: LQIP_WIDTH })
    .webp({ quality: 20 })
    .toBuffer();

  return `data:image/webp;base64,${buffer.toString('base64')}`;
}

async function main() {
  console.log('üñºÔ∏è  Image Optimization Script');
  console.log('='.repeat(60));

  const lqipMap = {};
  let totalOriginal = 0;
  let totalWebp = 0;
  let fileCount = 0;

  for (const dir of IMAGE_DIRS) {
    const files = await getImageFiles(dir);
    if (files.length === 0) continue;

    const relDir = dir.replace(PUBLIC_DIR, '/imagine');
    console.log(`\nüìÅ ${relDir}`);

    for (const file of files) {
      try {
        const result = await optimizeImage(file);
        const lqip = await generateLQIP(file);

        const relPath = file.replace(join(__dirname, '..', 'public'), '');
        const webpRelPath = result.webp.replace(join(__dirname, '..', 'public'), '');
        lqipMap[relPath] = lqip;

        totalOriginal += result.originalSize;
        totalWebp += result.webpSize;
        fileCount++;

        const origMB = (result.originalSize / 1024 / 1024).toFixed(1);
        const webpKB = (result.webpSize / 1024).toFixed(0);
        console.log(
          `  ‚úÖ ${basename(file)} ‚Üí ${basename(result.webp)} (${origMB}MB ‚Üí ${webpKB}KB, -${result.reduction}%)`
        );
      } catch (err) {
        console.error(`  ‚ùå ${basename(file)}: ${err.message}`);
      }
    }
  }

  // Write LQIP map as a TypeScript module
  const lqipOutput = join(
    __dirname,
    '..',
    'src',
    'features',
    'image-studio',
    'utils',
    'lqipMap.ts'
  );
  const lqipContent = `/**
 * Auto-generated LQIP (Low Quality Image Placeholder) map.
 * Generated by scripts/optimize-images.mjs
 * Do not edit manually.
 */
export const lqipMap: Record<string, string> = ${JSON.stringify(lqipMap, null, 2)};
`;
  await writeFile(lqipOutput, lqipContent);

  console.log('\n' + '='.repeat(60));
  console.log(
    `üìä Total: ${fileCount} files, ${(totalOriginal / 1024 / 1024).toFixed(1)}MB ‚Üí ${(totalWebp / 1024 / 1024).toFixed(1)}MB (-${((1 - totalWebp / totalOriginal) * 100).toFixed(1)}%)`
  );
  console.log(`üìÑ LQIP map written to: ${lqipOutput}`);
}

main().catch(console.error);
